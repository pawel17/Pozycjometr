
\chapter{Interfejs u¿ytkownika}

W poprzednim rodziale opisano wszystkie dzia³ania, które podjêto w
celu dokonania pomiaru przy¶pieszenia i k±ta obrotu uk³adu. Dane przes³ane
do komputera nie mog± byæ jedynie wy¶wietlone po stronie komputera
w postaci ci±gu znaków, gdy¿ to praktycznie uniemo¿liwia³oby analizê
otrzymywanych danych. Z tego wzglêdu konieczne jest odpowiednie przekszta³cenie
otrzymanych danych w sposób, który umo¿liwi zobrazowanie zmierzonych
przyspieszeñ b±d¼ obrotów. W tym celu przygotowano aplikacjê, której
zadaniem jest odbiór i wy¶wietlenie w formie graficznej wyników. Wykorzystano
do tego platformê .NET i jêzyk C\# z wykorzystaniem Windows Forms
dla stworzenia interfejsu. Powodem wyboru tej technologii by³a wzglêdna
prostota i mnogo¶æ klas i technik, które umo¿liwia³y osi±gniêcie postawionego
celu na systemie Windows. 


\section{Okno g³ówne aplikacji}

Okno g³ówne zrealizowanego programu przedstawiono na rysunku 7.1.

\begin{figure}
\begin{centering}
\includegraphics[scale=0.6]{rys/aplikacja/okno_glowne}
\par\end{centering}

\caption{Okno g³ówne programu}
\end{figure}


Otrzymane wyniki pomiaru przy¶pieszenia i k±ta obrotu wypisane s±
w odpowiednich polach, dla ka¿dej z osi osobno. Jednak¿e najwa¿niejszym
elementem aplikacji jest okno wy¶wietlania wyników pomiaru w formie
graficznej. Sze¶cian symbolizuje uk³ad pomiarowy, dodatkowo przedstawiono
osie uk³adu wspó³rzêdnych: o¶ X jest koloru niebieskiego, o¶ Y - ¿ó³tego
a o¶ Z jest czerwona. Dziêki temu mo¿na ³atwiej zaobserwowaæ wszelkie
przemieszczenia i zmiany k±ta wzglêdem po³o¿enia pocz±tkowego. Poni¿ej
okna wizualizacji umieszczono trzy prze³±czniki zgrupowane w panelu
Tryb pomiaru. Umo¿liwiaj± one prze³±czanie siê pomiêdzy trzema ró¿nymi
trybami wizualizacji. Obrót umo¿liwia obserwacjê jedynie wyników pracy
¿yroskopu, Przemieszczenie wy³±cza wizualizacjê obrotów bry³y pozostawiaj±c
przemieszczenie, a ostatni prze³±cznik pozwala na pe³ny podgl±d wyników
pomiarów. Przycisk Ustawienia pozwala na ustawienie parametrów po³±czenia
w osobnym oknie. Zostanie ono szczegó³owo opisane w kolejnej czê¶ci.
Wci¶niêcie przycisku O programie wy¶wietla szczegó³ow± informacjê
o zrealizowanej pracy in¿ynierskiej (Rysunek 7.3). 

\begin{figure}
\centering{}\includegraphics[scale=0.7]{rys/aplikacja/info}\caption{Okno informacji o programie}
\end{figure}


Za rozpoczêcie i zakoñczenie pomiarów odpowiadaj± przyciski Rozpocznij
pomiar i Zakoñcz pomiar. W jednej chwili tylko jeden z przycisków
jest aktywny, dziêki czemu nie ma mo¿liwo¶ci wielokrotnego zainicjalizowania/zakoñczenia
po³±czenia z wykorzystaniem interfejsu szeregowego. W przypadku próby
nawi±zania po³±czenia bez odpowiednio skonfigurowanych parametrów
po³±czenia wy¶wietlony zostanie odpowiedni komunikat informuj±cy o
konieczno¶ci poprawienia wprowadzonych danych (Rysunek.7.4).

\begin{figure}
\begin{centering}
\includegraphics[scale=0.7]{rys/aplikacja/blad}\caption{Okno b³êdu po³±czenia z portem COM}

\par\end{centering}

\end{figure}



\section{Okno ustawieñ}

Okno ustawieñ parametrów transmisji szeregowej przedstawiono na poni¿szej
ilustracji.

\begin{figure}
\begin{centering}
\includegraphics[scale=0.7]{rys/aplikacja/opcje}\caption{Opcje programu}

\par\end{centering}

\end{figure}


Kluczow± klas±, która s³u¿y do przechowywania parametrów po³±czenia
dostêpnych i wybranych jest klasa statyczna CommunicationParameters.
Klasa ta zapamiêtuje wybrane parametry transmisji danych i tablice
danych wy¶wietlanych w listach rozwijanych. Nazwy portów szeregowych
dostêpnych w danym komputerze otrzymano korzystaj±c z metody GetPortNames
klasy SerialPort znajduj±cej siê w przestrzeni nazw System.Port.IO,
wykorzystywanej w aplikacji do komunikacji z mikroprocesorem. Aby
rozpocz±æ pomiar konieczne jest jedynie wybranie odpowiedniej nazwy
portu. Reszta parametrów domy¶lnie ustawiona jest na warto¶ci, które
wybrano ju¿ w momencie konfiguracji komunikacji poprzez interfejs
UART w mikroprocesorze. W przypadku zmiany tych parametrów, konieczne
jest wybranie odpowiednich warto¶ci w oknie opcji. Klikniêcie przycisku
Zapisz powoduje zapamiêtanie wybranych parametrów i powrót do okna
g³ownego.


\section{Komunikacja z portem szeregowym}

Pierwszym zadaniem, jakie by³o konieczne do zrealizowania wymaga³o
odebrania danych pomiarowych otrzymanych z mikroprocesora za po¶rednictwem
portu szeregowego. Za komunikacjê z tym mikroprocesorem za po¶rednictwem
tego portu odpowiedzialna jest klasa COMPortManager. Wykorzystano
w tym celu klasê SerialPort, o której wspomniano ju¿ wcze¶niej. Klasa
ta umo¿liwia kontrolê portów szeregowych komputera. Zapewnia ona komunikacjê
synchroniczn±, sterowan± zdarzeniami wspieraj±c± szereg typów kodowania:
ASCII, UTF8, Unicode i UTF32. 

Komunikacja z portem szeregowym odbywa siê w puli w±tków, dziêki czemu
wykonywana jest ona w tle. W przypadku, gdy za pomoc± tego portu otrzymane
zostan± dane, wywo³ywane jest zdarzenie obs³ugiwane przez metodê SerialPortDataRecieved.
Odczytuje ona dane otrzymane z portu szeregowego i zapisuje je w postaci
stringu. Nastêpnie dane te s± opakowane w klasê ReceivedDataEventArgs,
która odpowiada za przechowywanie danych zdarzenia. Potem wywo³ywane
jest zdarzenie z uzyskanymi wynikami, które przekazuje je do g³ównego
okna aplikacji. W klasie COMPortManager jest równie¿ zaimplementowana
metoda, której zadaniem jest wysy³anie do mikroprocesora komunikatu
o tre¶ci ``RESET'', który powoduje wyzerowanie dotychczasowych wyników
pomiarów.


\section{Przeliczenie otrzymanych wyników}

Klasa ApplicationWindow, wy¶wietlaj±ca g³ówne okno aplikacji odbiera
dane z klasy COMPortManager w procedurze obs³ugi zdarzenia. Dodatkowo
metoda ta rozpoczyna siê od spradzenia, czy wywo³ywanie nie jest wykonywane
spoza bie¿±cego w±tku. Je¶li taka sytuacja ma miejsce, metoda ta zapisywana
jest jako delegat, który zostaje wykonany asynchronicznie z argumentami
otrzymanymi z klasy obs³uguj±cej komunikacjê z portem szeregowym. 

String zawieraj±cy dane odczytane z akcelerometru i ¿yroskopu zostaje
nastêpnie rozdzielony na poszczególne dane. Trzy pierwsze stringi
zawieraj± dane pomiarowe dotycz±ce przyspieszenia zostaj±, kolejne
trzy to wyniki pomiarów ¿yroskopu. Zostaj± one zapisane do dwóch tablic
³añcuchów znakowych, a nastêpnie zostaj± przekszta³cone do postaci
liczb ca³okowitych, które pos³u¿± do dalszych przeliczeñ.



Otrzymane wyniki zapisywane s± do odpowiednich pól tekstowych w oknie
g³ównym aplikacji. Ze wzglêdu na fakt, i¿ wyliczone warto¶ci nie mog±
byæ bezpo¶rednio zapisane do klasy dzia³aj±cej w innym w±tku, konieczne
by³o zastosowanie metody Invoke klasy Dispatcher na obiekcie okna
wizualizacji. Klasa Dispatcher umo¿liwia zarz±dzenia kolejk± elementów
roboczych dla danego w±tku, w tym wypadku okna wizualizacji. Metoda
Invoke jako argument przyjmuje delegat do funkcji, która zostanie
na tym w±tku wykonana. T± funkcj± jest metoda klasy ApplicationWindow
o nazwie ApplyMovement, która jako argumenty przyjmuje dwie tablice
danych z wynikami z obu urz±dzeñ pomiarowych. Warto¶ci te s± przypisywane
do odpowiednich zmiennych Nale¿y tutaj zaznaczyæ, ¿e w przypadku,
gdy metoda ta wywo³ywana jest po raz pierwszy, wyniki pomiaru przesuniêcia/obrotu
s± bezpo¶rednio wpisywane do odpowiednich zmiennych w obiekcie okna
wizualizacji, a ich warto¶ci zapamiêtywane w odpowiedniej zmiennej
w klasie ApplicationWindow. Ka¿dy kolejny pomiar skutkuje zapisaniem
do okna liczby bêd±cej ró¿nic± poprzedniej i obecnej. Dziêki temu,
aktualizacja pozycji sze¶cianu skutkuje jego przesuniêciem jedynie
o warto¶æ bêd±c± ró¿nic± pomiêdzy dwoma kolejnymi pomiarami. Po zapisaniu
warto¶ci zmiennych, wywo³ywana jest w oknie metoda, której zadaniem
jest wykonanie wszytkich transformacji na sze¶cianie. 

Metoda powoduj±ca usuniêcie wszystkich transformacji równie¿ jest
wywo³ywana z wykorzystaniem metody Invoke klasy Dispatcher. Dziêki
niej mo¿na przywróciæ domy¶lne po³o¿enie sze¶cianiu i rozpocz±æ pomiar
od pocz±tku, okre¶laj±c bie¿±ce po³o¿enie uk³adu jako domy¶lne. Metoda
ta jest wywo³ywana ka¿dorazowo przy prze³±czaniu trybu wizualizacji,
jak równie¿ po zakoñczeniu pomiaru.


\section{Wizualizacja danych}

Bior±c pod uwagê za³o¿enia przyjête przed realizacj± pracy, by³ to
najwa¿niejszy etap w tworzeniu interfejsu u¿ytkownika. Konieczny by³
wybór takiej technologii, która dobrze wspó³gra³a z reszt± programu
napisan± w jêzyku C\# a jednocze¶nie zapewnia³aby du¿e mo¿liwo¶ci
wizualizacji danych w postaci obiektów trójwymiarowych. Z tego wzglêdu
zdecydowano siê skorzystaæ z Windows Presentation Foundation. Jest
to silnik graficzny oparty o grafikê wektorow±, który pozwala na szerokie
mo¿liwo¶ci tworzenia aplikacji. API w WPF opiera siê na jêzyku XML,
a dok³adniej wykorzystuje jego implementacjê o nazwie XAML. Zapewnia
on powi±zanie pomiêdzy interfejsem a logik± i umo¿liwia tworzenie
zaawansowanych kontrolek, grafiki 2D i 3D, animacji, dokumentów, multimediów
czy te¿ tekstu. Dodatkow± zalet± jest fakt, i¿ Windows Presentation
Foundation jest zawarta w Microsoft .NET Framework, co czyni j± ³atwodostêpn±
i zdoln± do pracy z innymi elementami biblioteki .NET Framework.

Okno wizualizacji zbudowane zosta³o jako biblioteka ³±czona dynamicznie.
Takie rozwi±zanie jest konieczne ze wzglêdu na fakt, i¿ okno stworzone
w WPF bêdzie umieszczone w interfejsie stworzonym za pomoc± Windows
Forms. Dodatkowo konieczne by³o pod³±czenie kilku bibliotek, które
s± konieczne w poprawnym dzia³aniu aplikacji. 

Podstawowym elementem tworz±cym grafikê 3D jest trójk±t. Stworzenie
za pomoc± trójk±tów sze¶cianu nie jest szczególnie trudnym wyzwaniem.
Problemem okaza³o siê narysowanie za pomoc± trójk±ta linii, które
oznacza³y osie uk³adu wspó³rzêdnych. Teoretycznie liniê mo¿na narysowaæ
z wykorzystaniem odpowiednio przeskalowanego prostok±ta, lecz w takim
wypadku pojawia siê problem z zapewnieniem odpowiedniego o¶wietlenia
i ustawienia kamery. Ze wzglêdu na znaczen trudno¶ci, jakie mog³a
nie¶æ ze sob± implementacja tego rozwi±zania, zdecydowano siê na wykorzytanie
biblioteki 3D Tools przygotowanej przez Microsoft. Zawiera ona klasê
ScreenSpaceLines3D, które pozwalaj± na proste kre¶lenie linii.

Jak ju¿ wspomniano w poprzednim paragrafie, dwie metody klasy ApplicationWindow
operuj± bezpo¶rednio na danych klasy MainWindow, odpowiadaj±cej za
wizualizacjê wyników pomiaru. Najwa¿niejsz± z metod w tej klasie jest
metoda ApplyTransformation, która na podstawie danych zapisanych przez
metodê ApplyMovement z interfejsu wykonuje odpowiednie transformacje
na sze¶cianie. W tym celu wykorzystywane s± dwie klasy: AxisAngleRotation3D
i TranslateTransform3D. Klasa AxisAngleRotation3D s³u¿y do obracania
danego obiektu. Do jej poprawnej pracy konieczne jest podanie osi
obrotu i k±ta, o jaki nale¿y obróciæ obiekt. TranslateTransform3D
przesuwa obiekt o dany wektor. Wspó³rzêdne wektora to warto¶ci otrzymane
z akcelerometru. Przyspieszenie obrazuje przesuniêcie obiektu od ¶rodka
uk³adu wspó³rzêdnych. Tak przygotowane obiekty tych klas dodaje siê
do kolekcji transformacji przypisanych do obiektu, w tym przypadku
sze¶cianu.

Powrót do stanu pocz±tkowego realizowany jest w metodzie RemoveAllTransformations.
Odczytywana jest kolekcja transformacji, które wykonano na obiekcie,
a nastêpnie s± one usuwane w kolejno¶ci odwrotnej do dodania. Dziêki
temu mamy pewno¶æ, ¿e wszystkie przesuniêcia i obroty zostan± poprawnie
usuniête i obiekt powróci do domy¶lego po³o¿enia.
