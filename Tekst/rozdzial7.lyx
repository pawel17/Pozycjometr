#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass aghdpl
\use_default_options true
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Interfejs użytkownika
\end_layout

\begin_layout Standard
W poprzednim rodziale opisano wszystkie działania, które podjęto w celu
 dokonania pomiaru przyśpieszenia i kąta obrotu układu.
 Dane przesłane do komputera nie mogą być jedynie wyświetlone po stronie
 komputera w postaci ciągu znaków, gdyż to praktycznie uniemożliwiałoby
 analizę otrzymywanych danych.
 Z tego względu konieczne jest odpowiednie przekształcenie otrzymanych danych
 w sposób, który umożliwi zobrazowanie zmierzonych przyspieszeń bądź obrotów.
 W tym celu przygotowano aplikację, której zadaniem jest odbiór i wyświetlenie
 w formie graficznej wyników.
 Wykorzystano do tego platformę .NET i język C# z wykorzystaniem Windows
 Forms dla stworzenia interfejsu.
 Powodem wyboru tej technologii była względna prostota oraz mnogość klas
 i technik, które umożliwiały osiągnięcie postawionego celu na systemie
 Windows.
 
\end_layout

\begin_layout Section
Okno główne aplikacji
\end_layout

\begin_layout Standard
Okno główne zrealizowanego programu przedstawiono na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Okno-główne-programu"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rys/aplikacja/okno_glowne.png
	lyxscale 70
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Okno główne programu
\begin_inset CommandInset label
LatexCommand label
name "fig:Okno-główne-programu"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otrzymane wyniki pomiaru przyśpieszenia i kąta obrotu wypisane są w odpowiednich
 polach, dla każdej z osi osobno.
 Jednakże najważniejszym elementem aplikacji jest okno wyświetlania wyników
 pomiaru w formie graficznej.
 Sześcian symbolizuje układ pomiarowy, dodatkowo przedstawiono osie układu
 współrzędnych: oś X jest koloru niebieskiego, oś Y - żółtego a oś Z jest
 czerwona.
 Dzięki temu można łatwiej zaobserwować wszelkie przemieszczenia i zmiany
 kąta względem położenia początkowego.
 Poniżej okna wizualizacji umieszczono trzy przełączniki zgrupowane w panelu
 Tryb pomiaru.
 Umożliwiają one przełączanie się pomiędzy trzema różnymi trybami wizualizacji.
 Obrót umożliwia obserwację jedynie wyników pracy żyroskopu, Przemieszczenie
 wyłącza wizualizację obrotów bryły pozostawiając przemieszczenie, a ostatni
 przełącznik pozwala na pełny podgląd wyników pomiarów.
 Przycisk Ustawienia pozwala na ustawienie parametrów połączenia w osobnym
 oknie.
 Zostanie ono szczegółowo opisane w kolejnej części.
 Wciśnięcie przycisku O programie wyświetla szczegółową informację o zrealizowan
ej pracy inżynierskiej (Rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Okno-informacji-o-programie"

\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rys/aplikacja/info.png
	lyxscale 70
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Okno informacji o programie
\begin_inset CommandInset label
LatexCommand label
name "fig:Okno-informacji-o-programie"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Za rozpoczęcie i zakończenie pomiarów odpowiadają przyciski Rozpocznij pomiar
 i Zakończ pomiar.
 W jednej chwili tylko jeden z przycisków jest aktywny, dzięki czemu nie
 ma możliwości wielokrotnego zainicjalizowania/zakończenia połączenia z
 wykorzystaniem interfejsu szeregowego.
 W przypadku próby nawiązania połączenia bez odpowiednio skonfigurowanych
 parametrów połączenia wyświetlony zostanie odpowiedni komunikat informujący
 o konieczności poprawienia wprowadzonych danych (Rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Okno-błędu-połączenia"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rys/aplikacja/blad.png
	lyxscale 70
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Okno błędu połączenia z portem COM
\begin_inset CommandInset label
LatexCommand label
name "fig:Okno-błędu-połączenia"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Okno ustawień
\end_layout

\begin_layout Standard
Okno ustawień parametrów transmisji szeregowej przedstawiono na poniższej
 ilustracji.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename rys/aplikacja/opcje.png
	lyxscale 70
	scale 70

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Opcje programu
\begin_inset CommandInset label
LatexCommand label
name "fig:Opcje-programu"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kluczową klasą, która służy do przechowywania parametrów połączenia dostępnych
 i wybranych jest klasa statyczna CommunicationParameters.
 Klasa ta zapamiętuje wybrane parametry transmisji danych i tablice danych
 wyświetlanych w listach rozwijanych.
 Nazwy portów szeregowych dostępnych w danym komputerze otrzymano korzystając
 z metody GetPortNames klasy SerialPort znajdującej się w przestrzeni nazw
 System.Port.IO, wykorzystywanej w aplikacji do komunikacji z mikroprocesorem.
 Aby rozpocząć pomiar konieczne jest jedynie wybranie odpowiedniej nazwy
 portu.
 Reszta parametrów domyślnie ustawiona jest na wartości, które wybrano już
 w momencie konfiguracji komunikacji poprzez interfejs UART w mikroprocesorze.
 W przypadku zmiany tych parametrów, konieczne jest wybranie odpowiednich
 wartości w oknie opcji.
 Kliknięcie przycisku Zapisz powoduje zapamiętanie wybranych parametrów
 i powrót do okna głownego.
\end_layout

\begin_layout Section
Komunikacja z portem szeregowym
\end_layout

\begin_layout Standard
Pierwszym zadaniem, jakie było konieczne do zrealizowania wymagało odebrania
 danych pomiarowych otrzymanych z mikroprocesora za pośrednictwem portu
 szeregowego.
 Za komunikację z tym mikroprocesorem za pośrednictwem tego portu odpowiedzialna
 jest klasa COMPortManager.
 Wykorzystano w tym celu klasę SerialPort, o której wspomniano już wcześniej.
 Klasa ta umożliwia kontrolę portów szeregowych komputera.
 Zapewnia ona komunikację synchroniczną, sterowaną zdarzeniami wspierającą
 szereg typów kodowania: ASCII, UTF8, Unicode i UTF32.
 
\end_layout

\begin_layout Standard
Komunikacja z portem szeregowym odbywa się w puli wątków, dzięki czemu wykonywan
a jest ona w tle.
 W przypadku, gdy za pomocą tego portu otrzymane zostaną dane, wywoływane
 jest zdarzenie obsługiwane przez metodę SerialPortDataRecieved.
 Odczytuje ona dane otrzymane z portu szeregowego i zapisuje je w postaci
 stringu.
 Następnie dane te są opakowane w klasę ReceivedDataEventArgs, która odpowiada
 za przechowywanie danych zdarzenia.
 Potem wywoływane jest zdarzenie z uzyskanymi wynikami, które przekazuje
 je do głównego okna aplikacji.
 W klasie COMPortManager jest również zaimplementowana metoda, której zadaniem
 jest wysyłanie do mikroprocesora komunikatu o treści 
\begin_inset Quotes eld
\end_inset

RESET
\begin_inset Quotes erd
\end_inset

, który powoduje wyzerowanie dotychczasowych wyników pomiarów.
\end_layout

\begin_layout Section
Przeliczenie otrzymanych wyników
\end_layout

\begin_layout Standard
Klasa ApplicationWindow, wyświetlająca główne okno aplikacji odbiera dane
 z klasy COMPortManager w procedurze obsługi zdarzenia.
 Dodatkowo metoda ta rozpoczyna się od spradzenia, czy wywoływanie nie jest
 wykonywane spoza bieżącego wątku.
 Jeśli taka sytuacja ma miejsce, metoda ta zapisywana jest jako delegat,
 który zostaje wykonany asynchronicznie z argumentami otrzymanymi z klasy
 obsługującej komunikację z portem szeregowym.
 
\end_layout

\begin_layout Standard
String zawierający dane odczytane z akcelerometru i żyroskopu zostaje następnie
 rozdzielony na poszczególne dane.
 Trzy pierwsze stringi zawierają dane pomiarowe dotyczące przyspieszenia
 zostają, kolejne trzy to wyniki pomiarów żyroskopu.
 Zostają one zapisane do dwóch tablic łańcuchów znakowych, a następnie zostają
 przekształcone do postaci liczb całokowitych, które posłużą do dalszych
 przeliczeń.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Tutaj proponowałbym opisanie obliczeń
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otrzymane wyniki zapisywane są do odpowiednich pól tekstowych w oknie głównym
 aplikacji.
 Ze względu na fakt, iż wyliczone wartości nie mogą być bezpośrednio zapisane
 do klasy działającej w innym wątku, konieczne było zastosowanie metody
 Invoke klasy Dispatcher na obiekcie okna wizualizacji.
 Klasa Dispatcher umożliwia zarządzenia kolejką elementów roboczych dla
 danego wątku, w tym wypadku okna wizualizacji.
 Metoda Invoke jako argument przyjmuje delegat do funkcji, która zostanie
 na tym wątku wykonana.
 Tą funkcją jest metoda klasy ApplicationWindow o nazwie ApplyMovement,
 która jako argumenty przyjmuje dwie tablice danych z wynikami z obu urządzeń
 pomiarowych.
 Wartości te są przypisywane do odpowiednich zmiennych Należy tutaj zaznaczyć,
 że w przypadku, gdy metoda ta wywoływana jest po raz pierwszy, wyniki pomiaru
 przesunięcia/obrotu są bezpośrednio wpisywane do odpowiednich zmiennych
 w obiekcie okna wizualizacji, a ich wartości zapamiętywane w odpowiedniej
 zmiennej w klasie ApplicationWindow.
 Każdy kolejny pomiar skutkuje zapisaniem do okna liczby będącej różnicą
 poprzedniej i obecnej.
 Dzięki temu, aktualizacja pozycji sześcianu skutkuje jego przesunięciem
 jedynie o wartość będącą różnicą pomiędzy dwoma kolejnymi pomiarami.
 Po zapisaniu wartości zmiennych, wywoływana jest w oknie metoda, której
 zadaniem jest wykonanie wszytkich transformacji na sześcianie.
 
\end_layout

\begin_layout Standard
Metoda powodująca usunięcie wszystkich transformacji również jest wywoływana
 z wykorzystaniem metody Invoke klasy Dispatcher.
 Dzięki niej można przywrócić domyślne położenie sześcianiu i rozpocząć
 pomiar od początku, określając bieżące położenie układu jako domyślne.
 Metoda ta jest wywoływana każdorazowo przy przełączaniu trybu wizualizacji,
 jak również po zakończeniu pomiaru.
\end_layout

\begin_layout Section
Wizualizacja danych
\end_layout

\begin_layout Standard
Biorąc pod uwagę założenia przyjęte przed realizacją pracy, był to najważniejszy
 etap w tworzeniu interfejsu użytkownika.
 Konieczny był wybór takiej technologii, która dobrze współgrała z resztą
 programu napisaną w języku C# a jednocześnie zapewniałaby duże możliwości
 wizualizacji danych w postaci obiektów trójwymiarowych.
 Z tego względu zdecydowano się skorzystać z Windows Presentation Foundation.
 Jest to silnik graficzny oparty o grafikę wektorową, który pozwala na szerokie
 możliwości tworzenia aplikacji.
 API w WPF opiera się na języku XML, a dokładniej wykorzystuje jego implementacj
ę o nazwie XAML.
 Zapewnia on powiązanie pomiędzy interfejsem a logiką i umożliwia tworzenie
 zaawansowanych kontrolek, grafiki 2D i 3D, animacji, dokumentów, multimediów
 czy też tekstu.
 Dodatkową zaletą jest fakt, iż Windows Presentation Foundation jest zawarta
 w Microsoft .NET Framework, co czyni ją łatwodostępną i zdolną do pracy
 z innymi elementami biblioteki .NET Framework.
\end_layout

\begin_layout Standard
Okno wizualizacji zbudowane zostało jako biblioteka łączona dynamicznie.
 Takie rozwiązanie jest konieczne ze względu na fakt, iż okno stworzone
 w WPF będzie umieszczone w interfejsie stworzonym za pomocą Windows Forms.
 Dodatkowo konieczne było podłączenie kilku bibliotek, które są konieczne
 w poprawnym działaniu aplikacji.
 
\end_layout

\begin_layout Standard
Podstawowym elementem tworzącym grafikę 3D jest trójkąt.
 Stworzenie za pomocą trójkątów sześcianu nie jest szczególnie trudnym wyzwaniem.
 Problemem okazało się narysowanie za pomocą trójkąta linii, które oznaczały
 osie układu współrzędnych.
 Teoretycznie linię można narysować z wykorzystaniem odpowiednio przeskalowanego
 prostokąta, lecz w takim wypadku pojawia się problem z zapewnieniem odpowiednie
go oświetlenia i ustawienia kamery.
 Ze względu na znaczen trudności, jakie mogła nieść ze sobą implementacja
 tego rozwiązania, zdecydowano się na wykorzytanie biblioteki 3D Tools przygotow
anej przez Microsoft.
 Zawiera ona klasę ScreenSpaceLines3D, które pozwalają na proste kreślenie
 linii.
\end_layout

\begin_layout Standard
Jak już wspomniano w poprzednim paragrafie, dwie metody klasy ApplicationWindow
 operują bezpośrednio na danych klasy MainWindow, odpowiadającej za wizualizację
 wyników pomiaru.
 Najważniejszą z metod w tej klasie jest metoda ApplyTransformation, która
 na podstawie danych zapisanych przez metodę ApplyMovement z interfejsu
 wykonuje odpowiednie transformacje na sześcianie.
 W tym celu wykorzystywane są dwie klasy: AxisAngleRotation3D i TranslateTransfo
rm3D.
 Klasa AxisAngleRotation3D służy do obracania danego obiektu.
 Do jej poprawnej pracy konieczne jest podanie osi obrotu i kąta, o jaki
 należy obrócić obiekt.
 TranslateTransform3D przesuwa obiekt o dany wektor.
 Współrzędne wektora to wartości otrzymane z akcelerometru.
 Przyspieszenie obrazuje przesunięcie obiektu od środka układu współrzędnych.
 Tak przygotowane obiekty tych klas dodaje się do kolekcji transformacji
 przypisanych do obiektu, w tym przypadku sześcianu.
\end_layout

\begin_layout Standard
Powrót do stanu początkowego realizowany jest w metodzie RemoveAllTransformation
s.
 Odczytywana jest kolekcja transformacji, które wykonano na obiekcie, a
 następnie są one usuwane w kolejności odwrotnej do dodania.
 Dzięki temu mamy pewność, że wszystkie przesunięcia i obroty zostaną poprawnie
 usunięte i obiekt powróci do domyślego położenia.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand nocite
key "3Dtools,draw_cube,net_class_library,serial_port,transformations,uart_interupt,wpf3D_in_wf,wpf_in_wf"

\end_inset


\begin_inset CommandInset citation
LatexCommand nocite
key "wpf_lines"

\end_inset


\end_layout

\end_body
\end_document
